#!/usr/bin/env python

import os
import sys
import re
import subprocess
import ConfigParser
import io
sys.dont_write_bytecode = True

import imp
project = imp.load_source('project', '../project')

# build all possible (according project file)
def all():
	print("Building ALL")
	subprocess.call(['python', '-B', 'waf', 'all'])

# build specific (with specified arguments)
def build(args):
	print("Building")
	subprocess.call(['python', '-B', 'waf', 'build'] + args)

# clean
def clean():
	print("Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean', 'configure'])

# distclean
def distclean():
	print("Dist Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean'])

def repo_path():
	return os.path.dirname(os.path.dirname(os.path.realpath(__file__)))

def repo_clear():
	output = subprocess.check_output(['git', 'status', '-s'], cwd=repo_path())
	if output:
		print(output)
		return False
	return True

def repo_dirty():
	return not repo_clear()

# commit build (all) to specific repository (according project file)
def release(bumping):
	if not bumping in {'major', 'minor', 'patch'}:
		print('Usage: golem release { major | minor | patch }')
		return
	
	with io.open('../project', 'rb') as f:
		file_content = f.read().decode('utf-8')
	match = re.search('VERSION\s*=\s*(.*)', file_content)

	if not match:
		print "ERROR: No VERSION found in the project file"
		print "Before trying to Release, you should define a VERSION variable in your project. VERSION is a string using Semantic Versioning. Example: VERSION = 'v1.0.0'"
		return
	else:
		found = True
		version = match.group(1).strip('\'"')

	if repo_dirty():
		print("Your repository is dirty. You have to commit before releasing!")
		return

	parse = re.compile(r"(?P<major>\d+)\.?(?P<minor>\d+)?\.?(?P<patch>\d+)?(\-(?P<release>[a-z]+))?", re.VERBOSE)
	match = parse.search(version)
	
	parsed = {}
	if not match:
		print("Unrecognized version format")
		return
	
	for key, value in match.groupdict().items():
		if key == 'release':
			if value is None:
				parsed[key] = None
			else:
				parsed[key] = str(value)
		else:
			if value is None:
				parsed[key] = 0
			else:
				parsed[key] = int(value)

	bumped = False

	for key, value in parsed.items():
		if bumped:
			parsed[key] = 0
		elif key == bumping:
			parsed[key] = value + 1
			bumped = True

	serialized = 'v{major}.{minor}.{patch}'
	
	if parsed['release'] is not None:
		serialized += '-{release}'

	newversion = serialized.format(**parsed)
	
	default_message = "Bump " + str(version) + " to " + newversion
	message = default_message

	file_content = re.sub('^VERSION\s*=\s*(.*)', 'VERSION = \'' + newversion + '\'', file_content, flags=re.MULTILINE)
	
	with io.open('../project', 'wb') as f:
		file_content = file_content.encode('utf-8')
		f.write(file_content)
	
	output = subprocess.check_output(['git', 'add', 'project'], cwd=repo_path())
	if output:
		print output

	output = subprocess.check_output(['git', 'commit', '-m', message], cwd=repo_path())
	if output:
		print output
	
	output = subprocess.check_output(['git', 'tag', '-a', newversion, '-m', message], cwd=repo_path())
	if output:
		print output
		
	print "Released " + newversion

	return

# update deps and git
def update():
	print("Updating")

def about():
	print("=== Golem C++ Build System ===")

def invalid_command(arg):
	print(arg + " : Invalid command")

about()

if len(sys.argv) < 2:
	sys.exit(0)

arg = sys.argv[1]

if arg == 'all':
	all()
elif arg == 'build':
	build(sys.argv[2:])
elif arg == 'clean': 
	clean()
elif arg == 'release':
	if len(sys.argv) < 3:
		print('Usage golem release { major | minor | patch }')
		sys.exit(0) 
	release(sys.argv[2])
elif arg == 'update': 
	update()
elif arg == 'distclean': 
	distclean()
else:
	invalid_command(arg)

import os
import sys
import platform

def identifier(flags):
	return hash(str(flags))

def compiler():
	return 'vc140'

def some_declaration():
	name = 'bidon'
	flags = [ '/MT', '/O3' ]
	runtimes 	= [ 'shared', 'static' ]
	targets		= [ 'shared', 'static', 'program' ]
	variants 	= [ 'release', 'debug' ]
	archs		= [ 'x86', 'x64' ]
	systems		= [ 'windows', 'linux', 'macos' ]


def build():
	for arch in 'x86 x64'.split():
		for link in 'shared static'.split():
			for variant in 'debug release'.split():
				os.makedirs('out/' + name + '-')
	return

def branch(name, system, compiler, arch, runtime, target, variant, flags):
	return name + '-' + system + '-' + compiler + '-' + arch + '-' + runtime + '-' + target + '-' + variant + '-' + identifier(flags)


class Dependency:
	def __init__(self):
		self.name = ''
		self.version = 'latest'
		self.system = sys.platform
		self.compiler = 'vc140'
		self.arch = platform.machine().lower()
		self.runtime = 'shared'
		self.target = 'shared'
		self.variant = 'release'
		self.hash = 'DEFAULT'
	def __str__(self):
		ret = ''
		ret += 'Name' 	+ '\t\t' + self.name + '\n'
		ret += 'Version' + '\t\t' + self.version + '\n'
		ret += 'System' 	+ '\t\t' + self.system + '\n'
		ret += 'Compiler' + '\t' + self.compiler + '\n'
		ret += 'Arch' 	+ '\t\t' + self.arch + '\n'
		ret += 'Runtime' + '\t\t' + self.runtime + '\n'
		ret += 'Target' 	+ '\t\t' + self.target + '\n'
		ret += 'Variant' + '\t\t' + self.variant + '\n'
		ret += 'Hash' 	+ '\t\t' + self.hash
		# ret += str(self.__dict__)
		return ret

class Project:
	def __init__(self):
		self.cache = []
		self.deps = []

	def __str__(self):
		ret = ''
		ret += 'Cache' + '\t' + str(self.cache) + '\n'
		ret += 'Deps' + '\t' + str(self.deps)
		return ret
	
	def get_deps(self):
		ret = []
		for fields in self.deps:
			dep = Dependency()
			for index, field in enumerate(fields):
				if not field:
					continue
				if index == 0:
					dep.name = field
				if index == 1:
					dep.version = field
			if dep.name:
				ret.append(dep)
		return ret

def print_project():
	conf = Project()
	project.deps(conf)
	print conf
	for dep in conf.get_deps():
		print dep

def print_subdir():
	print [x[1][0] for x in os.walk('out') if x[1]]