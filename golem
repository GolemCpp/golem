#!/usr/bin/env python

import os
import sys
import re
import subprocess
import ConfigParser
import io
import distutils.dir_util
sys.dont_write_bytecode = True

import imp
project = imp.load_source('project', '../project.glm')

# build all possible (according project file)
def all():
	print("Building ALL")
	subprocess.call(['python', '-B', 'waf', 'all'])

# build specific (with specified arguments)
def build(args):
	print("Building")
	subprocess.call(['python', '-B', 'waf', 'configure', 'build'] + args)

# build specific (with specified arguments)
def test(args):
	print("Testing")
	subprocess.call(['python', '-B', 'waf', 'test'] + args)

# clean
def clean():
	print("Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean', 'configure'])

# distclean
def distclean():
	print("Dist Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean'])

# commit build (all) to specific repository (according project file)
def release(args):
	subprocess.call(['python', '-B', 'waf', 'release'] + args)

# update deps and git
def update():
	print "Updating"

def about():
	print "=== Golem C++ Build System ==="

def invalid_command(arg):
	print(arg + " : Invalid command")

about()

if len(sys.argv) < 2:
	sys.exit(0)

arg = sys.argv[1]

if arg == 'all':
	all()
elif arg == 'build':
	build(sys.argv[2:])
elif arg == 'test':
	test(sys.argv[2:])
elif arg == 'clean': 
	clean()
elif arg == 'release':
	release(sys.argv[2:])
elif arg == 'update': 
	update()
elif arg == 'distclean': 
	distclean()
else:
	invalid_command(arg)