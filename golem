#!/usr/bin/env python

import os
import sys
import re
import subprocess
import ConfigParser
import io
import distutils.dir_util
sys.dont_write_bytecode = True

import imp
project = imp.load_source('project', '../project.glm')

# build all possible (according project file)
def all():
	print("Building ALL")
	subprocess.call(['python', '-B', 'waf', 'all'])

# build specific (with specified arguments)
def build(args):
	print("Building")
	subprocess.call(['python', '-B', 'waf', 'configure', 'build'] + args)

# build specific (with specified arguments)
def test(args):
	print("Testing")
	subprocess.call(['python', '-B', 'waf', 'test'] + args)

# clean
def clean():
	print("Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean', 'configure'])

# distclean
def distclean():
	print("Dist Cleaning")
	subprocess.call(['python', '-B', 'waf', 'distclean'])

def repo_path():
	return os.path.dirname(os.path.dirname(os.path.realpath(__file__)))

def repo_clear():
	output = subprocess.check_output(['git', 'status', '-s'], cwd=repo_path())
	if output:
		print(output)
		return False
	return True

def repo_dirty():
	return not repo_clear()

# commit build (all) to specific repository (according project file)
def release(args):
	if not len(args):
		print('Usage golem release { major | minor | patch }')
		sys.exit(0)
	bumping = args[0]
	
	if not bumping in {'major', 'minor', 'patch'}:
		print('Usage: golem release { major | minor | patch }')
		return
	
	with io.open('../project.glm', 'rb') as f:
		file_content = f.read().decode('utf-8')
	match = re.search('VERSION\s*=\s*(.*)', file_content)

	if not match:
		print "ERROR: No VERSION found in the project file"
		print "Before trying to Release, you should define a VERSION variable in your project. VERSION is a string using Semantic Versioning. Example: VERSION = 'v1.0.0'"
		return
	else:
		found = True
		version = match.group(1).strip('\'"')

	if repo_dirty():
		print("Your repository is dirty. You have to commit before releasing!")
		return

	parse = re.compile(r"(?P<major>\d+)\.?(?P<minor>\d+)?\.?(?P<patch>\d+)?(\-(?P<release>[a-z]+))?", re.VERBOSE)
	match = parse.search(version)
	
	parsed = {}
	if not match:
		print("Unrecognized version format")
		return
	
	for key, value in match.groupdict().items():
		if key == 'release':
			if value is None:
				parsed[key] = None
			else:
				parsed[key] = str(value)
		else:
			if value is None:
				parsed[key] = 0
			else:
				parsed[key] = int(value)

	bumped = False

	for key, value in parsed.items():
		if bumped:
			parsed[key] = 0
		elif key == bumping:
			parsed[key] = value + 1
			bumped = True

	serialized = 'v{major}.{minor}.{patch}'
	
	if parsed['release'] is not None:
		serialized += '-{release}'

	newversion = serialized.format(**parsed)
	
	default_message = "Bump " + str(version) + " to " + newversion
	message = default_message

	file_content = re.sub('^VERSION\s*=\s*(.*)', 'VERSION = \'' + newversion + '\'', file_content, flags=re.MULTILINE)
	
	with io.open('../project.glm', 'wb') as f:
		file_content = file_content.encode('utf-8')
		f.write(file_content)
	
	output = subprocess.check_output(['git', 'add', 'project'], cwd=repo_path())
	if output:
		print output

	output = subprocess.check_output(['git', 'commit', '-m', message], cwd=repo_path())
	if output:
		print output
	
	output = subprocess.check_output(['git', 'tag', '-a', newversion, '-m', message], cwd=repo_path())
	if output:
		print output
		
	print "Released " + newversion

# update deps and git
def update():
	print "Updating"

def about():
	print "=== Golem C++ Build System ==="

def invalid_command(arg):
	print(arg + " : Invalid command")

about()

if len(sys.argv) < 2:
	sys.exit(0)

arg = sys.argv[1]

if arg == 'all':
	all()
elif arg == 'build':
	build(sys.argv[2:])
elif arg == 'test':
	test(sys.argv[2:])
elif arg == 'clean': 
	clean()
elif arg == 'release':
	release(sys.argv[2:])
elif arg == 'update': 
	update()
elif arg == 'distclean': 
	distclean()
else:
	invalid_command(arg)